---
title: OSスレッド
---

RustのOSスレッドに関するAPIを説明する前に、まずOSにおけるスレッドについて少し説明しましょう。以下では主にOSとしてLinuxを想定して説明しますが、WindowsでもmacOSでも概ね同じような内容になる部分だけを見ていきます。またカーネルの事を指してOSと呼びます。

# プロセスとスレッド
OSはユーザーが起動した複数のアプリケーションを同時に動かす必要があります。例えばこの本で対象としているような数値計算では、典型的にはシェルで

```shell
./a.out
```

のようにして計算を開始しますが、ここではこれをアプリケーションと呼びましょう。OSはまずアプリケーション毎にプロセスと呼ばれるリソースの管理単位を作ります。例えば二つのアプリケーションを起動したとき、片方のアプリケーションが確保したメモリをほかのアプリケーションから見れてしまうと色々困ります。そこで確保されたメモリはプロセスが管理するリソースとして扱い、別のプロセスからは見えないようにします。

もう一つの重要なリソースがスレッドです。OSはプログラムの実行をスレッドという単位で管理します。アプリケーションを起動するとプロセスの中にメインスレッドと呼ばれるスレッドが作られます。このメインスレッドは `main` 関数を最初から実行していきます。OSはCPUのコアに対してたくさんのスレッドを順番に割り当てて実行させます。それぞれのスレッドの処理はすぐに終わるとは限らないので、OSは典型的には一定の時間が経過するとCPUのコアを別のスレッドに割り当てて、それまで実行されていたスレッドは順番待ちになります。このようにしてOSは複数のスレッドを同時に実行しているように見せます。

TODO: ここにスレッド割り当ての図を入れる

プロセスには起動時にメインスレッドが作られますが、追加でスレッドを作ることもできます。新しいスレッドも同じプロセスに所属するので、メモリなどのリソースはそのプロセスに所属するスレッドと共有されます。OSはそれぞれのスレッドをそれぞれのCPUコアに割り当てるので、複数のCPUコアがある場合は複数のスレッドが同時に実行されます。このスレッド達はそれぞれ独立に動作しているので、例えばメモリのある位置に同時に書き込もうとすると問題になります。これを防ぐためにハードウェアレベル、OSレベル、プログラムレベルで色々な対策が取られており、このページではそれらをRustから使う方法についてまとめていきます。

# スレッドの作成

スレッドの起動はOSにスレッドを起動するように指示することになるのでOSに依存した処理ですが、Rustでは標準ライブラリがOSに依存した処理を隠蔽して、プログラムからはOSに依存した処理を意識することなくスレッドを起動できるようになっています。スレッドを起動するには `std::thread::spawn` 関数を使います。

```rust
let thread = std::thread::spawn(/* 新たに起動するスレッドで行う処理を記述する */ || {
    // まず1秒待つ
    std::thread::sleep(std::time::Duration::from_secs(1));
    // 1を返す
    return 1;
});

let result = thread.join().unwrap();
assert_eq!(result, 1);
```
