---
title: リンクと共有ライブラリ
---

ここではRustと他の言語との相互運用についての準備として、Linuxにおけるオブジェクトファイルのリンクと、共有ライブラリのロードに関する話をします。これはOS（カーネルに加えて開発用のツールチェインを含めた意味）に強く依存する部分ですが、WindowsやmacOSでもいくつかの環境変数やコマンドを読み替えるだけで概ね同じになる範囲を扱います。

実行可能なファイルとリンク
-------------------------
Rustで実行可能なターゲット (`src/bin/main.rs`のようなファイル) を含むプロジェクトをビルドすると実行ファイルが出来上がりますが、どうしてOSはこれを実行できるのでしょうか？　OSはそれぞれが実行可能なファイルのフォーマットを規定していて、それにそってファイルを作成することで実行可能なファイルを作成できます。Linuxでは[ELF (Executable and Linkable Format)](https://ja.wikipedia.org/wiki/Executable_and_Linkable_Format)というフォーマットが使われています。

その名の通りELFにはリンク可能なファイルを格納する事が出来ます。例えば数百ファイルのソースコードからなるプロジェクトがあるとしましょう。これらのソースコードをコンパイルして1つの実行可能なファイルを一気に作るのは大変なので、それぞれのソースコードファイルを個別にコンパイルして、最後にそれらを結合出来ると便利です。この結合処理の事をリンクと呼び、個別にコンパイルされたデータを保存したファイルをオブジェクトファイルと呼びます。オブジェクトファイルもELF形式で保存でき、ファイル名に`.o`という拡張子を使うことが多いです。別のソースコードで実装された関数を呼び出すような操作はオブジェクトファイルの段階では「どこかの〇〇という名前の関数を呼び出す」という形で記録されているだけで、実際に呼び出す関数がどこにあるかは分かっていません。リンクの処理はこれらの呼び出しを実際の関数のアドレスに置き換える処理を行います。

ELFで表現できるもう1つの重要ものとして共有ライブラリがあります。これは実行時にロードして呼び出すことが出来る命令の塊です。複数の実行可能なファイルで共通の処理を共有ライブラリとして使うことでファイルを小さくできるほか、プログラムを再コンパイルすることなく機能を追加するプラグイン機能の実装、あるいはプロセスを停止させずに実装を挿げ替えたりするのに使う事が出来ます。またOSの機能の幾つかは共有ライブラリとして提供されます。

共通基盤としてのC言語
--------------------
以下ではリンクについての基本的な事項をC言語で説明していきます。何故ならリンクのためのツールはまずC言語で動くように設計されており、なのでC言語の基本的な概念がそのままリンクの基本的な概念として現れるからです。Rustや他の多くの言語 (例えばC++) はC言語におけるリンクの仕組みの上に追加の情報を付加することで、ツールをそのまま利用しつつより高度なリンクを実現しています。

この意味でC言語はある種の共通基盤として使えます。複数の異なる言語で実装されたソースコードのそれぞれをあたかもC言語で実装されたかのようにオブジェクトファイルにコンパイルすることで、C言語で実装されたオブジェクトファイルと同じようにリンクできます。また共有ライブラリの呼び出しもC言語の関数呼び出しと同じように行うため、別の言語で実装されたソースコードをC言語の時と同じように共有ライブラリにコンパイルすることで、C言語で実装された共有ライブラリと同じように呼び出すことが出来ます。この際のインタフェースの事をABIと呼びます。

:::message
これはよくC ABIと呼ばれますが、あくまで定めているのはOS (および付属するリンカ・ローダ) であって、C言語自体が定めているわけではないことに注意してください。
:::

C言語の言語機能は例えばRustからみると非常に貧弱で構造体と関数くらいしかなく、Rustのような複雑な言語機能を持つ言語はOSが定めるABIに加えて、その上に独自のABIを定めることでより多くの情報を実行時に利用できるようにしています。残念ながらまだRustのABIは安定化されておらず、コンパイラのバージョンに依存します。別言語との相互運用を行う際には双方でこの追加のABIについての合意が無いので、これらの情報を予め捨てておく(`extern`構文を使う)、あるいは別途変換機構を用意する必要があることに注意してください。例えばRustからC++で実装された機能を呼び出す場合、C言語としてのABIを経由する必要があるのでC++の機能の多く (例えば仮想関数の呼び出し) を使うことは出来ません。

実行ファイルを作る
-----------------
さて実際に実行ファイルを作ってみましょう。次のC言語のファイル `a.c` を用意します

```c:a.c
#include <stdio.h>

void func_a() {
    puts("Hello from func_a");
}
```

`puts`というのはC言語の標準ライブラリにある標準出力に文字列を出力する関数です。これをオブジェクトファイル `a.o` にコンパイルしてみます。`gcc`コマンドは`-c`オプションをつけるとコンパイルだけを行いオブジェクトファイルを生成します：

```shell
gcc -c a.c  # a.oファイルが生成される
```

オブジェクトファイルにはCPUが直接読める機械語に変換された関数の実装が含まれていますが、リンク時にはこの機械語の束を入れ替えたりつなぎ合わせたりする必要があります。そこでビット列で表現される機械語を一列に並べておき、ある関数に対応する機械語がどの位置から始まるのかを別途覚えておき、これをシンボルと呼びます。オブジェクトファイルに含まれるシンボルの一覧は `nm` コマンドで取得できます：

```text
$ nm a.o
0000000000000000 T func_a
                 U puts
```

C言語における関数の名前がそのままシンボル名として現れます。ただし最適化が行われた後に呼び出される関数が現れることに注意してください。例えば`printf("Hello!")`のような文字列だけを`printf`するものは`puts`にコンパイル時に置換されるので`nm`すると`puts`が現れます。またマクロは全てコンパイル時に展開されるのでここには現れません。

`func_a`は今定義した関数を表し、このオブジェクトファイルにはこれしか含まれていないので先頭から始まり、対応するアドレスは `0000000000000000` となります。一方`puts`は上で述べた標準ライブラリの関数の事ですが、今このオブジェクトファイルには`puts`の実装は含まれていないので、対応するアドレスも空白になっています。`T`や`U`というのはシンボルタイプと呼ばれるもので、次の意味があります：

|シンボルタイプ | 説明 |
|:-------------|:-----|
|`T` | Text(Code)セクションに含まれている |
|`U` | 未定義(Undefined)シンボル |

さて実行ファイルの開始地点となる`main`関数を作って、上で定義した `func_a` を呼び出すとしましょう。

```c:main.c
void func_a();

int main() {
    func_a();
    return 0;
}
```

これをコンパイルして`nm`でシンボルを確認してみましょう：

```text
$ gcc -c main.c
$ nm main.o
                 U func_a
0000000000000000 T main
```

今度は`func_a`が未定義になってますね。この`main.c`には`func_a`の宣言だけあって定義がないので、`main`関数の途中で`func_a`の呼び出し時にどの機械語を実行すればいいのか分かりません。`gcc`コマンドはオプションをつけないと引数のファイルから実行ファイルを作ろうとします：

```text
$ gcc main.o
/usr/bin/ld: main.o: in function `main':
main.c:(.text+0xe): undefined reference to `func_a'
collect2: error: ld returned 1 exit status
```

このように未定義のシンボルがどこにあるのか分からない状態で実行ファイルを作ろうとすると`undefined reference`エラーが発生します。RustでCのライブラリを呼び出すコードを書く時だけでなく使う際にもこのエラーをよく見かける事になるので、仕組みを理解しておくと良いでしょう。さて`func_a`の実装は`a.o`に含まれているので、それも一緒に指定してあげます：

```text
$ gcc main.o a.o  # a.outという実行ファイルが生成される
$ ./a.out
This is func_a in a.c
```

`puts`はどこで指定してあげたのでしょうか？実は`gcc`コマンドによるリンクでは素のリンカコマンド`ld`と違ってCの標準ライブラリを自動的に追加します。C標準ライブラリの多くは`libc`に実装が含まれているので`-lc`オプションを`ld`に追加することでリンクできます。このように各言語はそれぞれの標準ライブラリを提供していて、それらはそれぞれの言語のコンパイラによって自動的にリンクされるようになっているので、別言語との相互運用を行う場合にはこの点に気を付ける必要があります。
