---
title: ndarrayのデータ構造
---

計算機のメモリは1次元(1つのアドレスだけで位置が指定される)なので多次元配列を一列に並べ直す必要があります。有限集合の積は有限集合なので、常に整列させることが出来ますが、普遍的な順序があるわけではありません。そのため様々な方法で並べ直す実装が行われてきました。例えば$I_1 = [N], I_2 = [M]$の場合に$[N \times M]$に並べるだけでも

- $I_1$の要素を連続になるように並べる $I_1 \times I_2 \ni (i, j) \mapsto i + jN \in [N \times M]$
- $I_2$の要素を連続になるように並べる $I_1 \times I_2 \ni (i, j) \mapsto iM + j \in [N \times M]$

という方法がとれます。3つ以上の積に対してもこの2つの方法は拡張でき、最初の要素をなるべく近い位置に並べるようにする前者をColumn-major orderあるいはFortran (F)-orderと呼び、最後の要素をなるべく近い位置に並べる後者をRow-major orderあるいはC-orderと呼びます。

いわゆるndarrayと呼ばれるデータ構造ではこのC/F-orderの並べ方を少し一般化してstrideという概念を導入します。これは引数の各有限集合について番号を1つ増やしたときにメモリ上でいくつ先に進むのかを決める整数の組です。例えば$I_1 = [N], I_2 = [M]$の上のケースではF-orderでは$I_1$の添字$i$を1つ増やしたとき$i + jN$は一つ増え、$j$を一つ増やした時$N$増えるのでstrideを$s_1 = 1, s_2 = N$のように定義します。C-orderの場合には$s_1 = M, s_2 = 1$となります。このようにC/F-orderはstrideを用いて記述でき、さらに三つ以上の場合にC/F-orderで記述出来ないケース、例えば$I_1 = [N], I_2 = [M], I_3 = [K]$の場合に$(s_1, s_2, s_3) = (1, NK, N)$のような表現が出来ます。

この時メモリが飛び飛びになることを許します。例えば上の例で$s_1 = 1, s_2 = 2N$とすると、メモリの$[0, N]$の部分に$a(0, 0), a(1, 0), \ldots, a(N-1, 0)$が並んだ後、$a(0, 1)$は$2N$に配置されるのでの$[N+1, 2N-1]$の区間には配列のデータが存在しないことになります。一見これはメモリ空間の無駄遣いになるだけで役に立たないように見えますが、添字の射影をとる操作を行う際に便利な事が分かります。
写像$a: I_1 \times I_2 \to T$がある時、$j \in I_2$を固定する毎に写像$$a(:, j): I_1 \ni i \mapsto a(i, j) \in T$$が作れますが、これもまた有限集合を始域にもつ写像なので配列として表示できるはずです。$I_1 = [N]$, $I_2 = [M]$として$a$が多次元配列としてメモリ上にstride$(s_1, s_2) = (M, 1)$で保存されているとする時、$a(0, j)$と$a(1, j)$はメモリ上で$s_1 = M$だけ離れています。つまりメモリが連続に並んでいることを要請しないことによって、このような部分配列をとる操作がメモリの再確保を行わずに表現出きるようになります。
