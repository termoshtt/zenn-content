---
title: テストを書く
---

# テストの役割と限界

テストの役割はコードが正しく動いている事を検証することです。特にプログラミングの文脈において「テスト」という単語は

- 代表的な（典型的には開発者がそのドメインの知識を用いて生成した少数の）入力に対する
- 実行時の検証

の事を指します。つまり開発者が「この入力に対してこの答えになってるなら多分上手く動いてるだろう」という大雑把な感覚をソースコードに落としたものです。これは限定的な入力しか検証していないので実装が正しいことを保証できませんが、実装が間違っていることを知ることはでき、そしてこれはソフトウェア開発において非常に有効に働くことが知られています。

上で言うテスト以外にも実装が正しいかどうかを検証する様々な方法が存在します。

- コンパイル時の型検査も実装が正しいかの検査です。このように実際に実装を実行せずに検証を行うものを静的検査と呼び、テストのように実装を実行してみるものを動的検査と呼びます。
- [clippy](https://github.com/rust-lang/rust-clippy)のようなよくあるミスをソースコードから直接発見的に見つけるツール(Linterと呼ばれる)も静的検査の一つです。
- 数学の証明のように静的に任意の入力に対する正しさを検証するために、実装を数学的にモデル化して検証する方法は[形式手法](https://ja.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%89%8B%E6%B3%95)と呼ばれます。テストに比べると検証のためのコストが大きいので、特にバグがあると人が死ぬようなソフトウェアやOSや分散データベースのような非同期処理が多用されテストでは検証が不可能な場合に用いられます。
- 動的に任意の入力に対する正しさを検証するために入力をひたすら間違いを見つけるまで生成し続ける方法は[Fuzzing](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0)と呼ばれます。コンパイラのように複雑な入力を扱わなければならず人間がケースを列挙する方法では難しい場合に使われます。例えば [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz) を調べるといいでしょう。

# 静的な検証と実行時の検証

我々はどのような間違ったコードを書くのでしょうか？

静的に検証できる事と実行時に検証しないといけない事がある事を認識することが大事です。例えば

```rust
fn f(a: i32) {
    dbg!(a);
}
```

のような関数があるときに、 `f(1.0)` のように `f64` を渡すのは静的に検査できる事です。


# テストケースの自動生成と簡略化

ここではproptestによるテストケースの自動生成と簡略化について議論します。

https://github.com/proptest-rs/proptest
