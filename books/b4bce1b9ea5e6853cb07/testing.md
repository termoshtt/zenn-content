---
title: テストを書く
---

数値計算で研究をしていると研究が進むたびに必要になった機能をどんどん実装し続けないといけません。ある機能を実装したらそれを使って実験をします。あなたは実験結果を可視化したところ上手くいっている図が得られて満足しこの機能（Aと呼びましょう）の開発は終わりました。

さて研究が進んで新しい機能Bが必要になりました。以前に実装した機能Aを少し変更すると機能Bの実装に使える事に気が付き、Aの実装を変更して機能Bを実装して実験し、結果を確認して新機能Bの実装は無事おわりました。

そして時は立ち機能Cを実装することになりました。やはりこれにも機能Aが、特に機能Bの時に使った部分とは別の部分が必要です。しかしこのコードは機能Bの時に変更されています。このコードは動くのでしょうか？機能Aを実装したのは随分と前です。試しに機能Cを実装してみましたがどうも結果がおかしいです。あなたはあきらめて機能Aのコードを読み始めます...

どうすればすぐに機能Cの実装に取り掛かれたのでしょうか？

# テストの役割と限界

テストの役割はコードが正しく動いている事を検証することです。特にプログラミングの文脈において「テスト」という単語は

- 代表的な（典型的には開発者がそのドメインの知識を用いて生成した少数の）入力に対する
- 実行時の検証

の事を指します。つまり開発者が「この入力に対してこの答えになってるなら多分上手く動いてるだろう」という大雑把な感覚をソースコードに落としたものです。これは限定的な入力しか検証していないので実装が正しいことを保証できませんが、実装が間違っていることを知ることはでき、そしてこれはソフトウェア開発において非常に有効に働くことが知られています。

上で言うテスト以外にも実装が正しいかどうかを検証する様々な方法が存在します。

- コンパイル時の型検査も実装が正しいかの検査です。このように実際に実装を実行せずに検証を行うものを静的検査と呼び、テストのように実装を実行してみるものを動的検査と呼びます。
- [clippy](https://github.com/rust-lang/rust-clippy)のようなよくあるミスをソースコードから直接発見的に見つけるツール(Linterと呼ばれる)も静的検査の一つです。
- 数学の証明のように静的に任意の入力に対する正しさを検証するために、実装を数学的にモデル化して検証する方法は[形式手法](https://ja.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%89%8B%E6%B3%95)と呼ばれます。テストに比べると検証のためのコストが大きいので、特にバグがあると人が死ぬようなソフトウェアやOSや分散データベースのような非同期処理が多用されテストでは検証が不可能な場合に用いられます。
- 動的に任意の入力に対する正しさを検証するために入力をひたすら間違いを見つけるまで生成し続ける方法は[Fuzzing](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0)と呼ばれます。コンパイラのように複雑な入力を扱わなければならず人間がケースを列挙する方法では難しい場合に使われます。例えば [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz) を調べるといいでしょう。

# 静的な検証と実行時の検証

我々はどのような間違ったコードを書くのでしょうか？

静的に検証できる事と実行時に検証しないといけない事がある事を認識することが大事です。例えば

```rust
fn f(a: i32) {
    dbg!(a);
}
```

のような関数があるときに、 `f(1.0)` のように `f64` を渡すのは静的に検査できる事です。


# テストケースの自動生成と簡略化

ここではproptestによるテストケースの自動生成と簡略化について議論します。

https://github.com/proptest-rs/proptest
