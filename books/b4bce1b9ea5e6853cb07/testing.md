---
title: テストを書く
---

# なぜテストを書くのか？
まずはモチベーションを理解するために次のようなストーリーを考えてみましょう。

数値計算で研究をしていると研究が進むたびに必要になった機能をどんどん実装し続けないといけません。ある機能を実装したらそれを使って実験をします。あなたは実験結果を可視化したところ上手くいっている図が得られて満足しこの機能（Aと呼びましょう）の開発は終わりました。
さて研究が進んで新しい機能Bが必要になりました。以前に実装した機能Aを少し変更すると機能Bの実装に使える事に気が付き、Aの実装を変更して機能Bを実装して実験し、結果を確認して新機能Bの実装は無事おわりました。
そして時は立ち機能Cを実装することになりました。やはりこれにも機能Aが、特に機能Bの時に使った部分とは別の部分が必要です。しかしこのコードは機能Bの時に変更されています。このコードは動くのでしょうか？機能Aを実装したのは随分と前です。試しに機能Aを使って機能Cを実装してみましたがどうも結果がおかしいです。結局あなたは機能Aの何が動いて何が動いていないのかを調べるため、ソースコードを読み始めることしました。しかしボスはなんで機能Cの実装は終わらないんだと怒り始めました...

このように次から次へと新しい開発項目が増えていってそれらを既存の機能を動くように保ちながら実装していくというのはソフトウェア開発において重要な課題であり、ソフトウェア開発がビジネスのコアとなっていくにしたがってその重要性は増していき様々な工夫が行われました。例えば次の資料によくまとまっています：

https://speakerdeck.com/twada/strategy-and-tactics-of-building-automated-testing-culture-into-organization-2020-autumn-edition?slide=10

その中で発達した技術の一つが自動テストです。自動テストの目的はどの機能が正しく動いているのかどうかを観測できるようにする事です。この本の初めに書いたようにこの本の目的の一つは一般的なソフトウェア開発において成功した技法を数値計算でも応用することです。
上の例で言えば機能Aにテストが整備されていたとすると、機能Cを実装するときはそのテストを実行するだけで機能Aが正しく動いているかどうかを確認できます。機能Bを実装するために機能Aの実装に手を入れたときも、そのテストを実行すれば機能Aの何がそのまま動いて何が動かなくなったのかが分かるので、必要以上に既存の機能を壊すことなく開発を行うことが出来るようになります。
このように自動テストは開発の効率を上げ、思いついた研究のアイディアを素早く検証することを補助してくれます。

# テストの役割と限界

テストの役割はコードが正しく動いている事を検証することです。特にプログラミングの文脈において「テスト」という単語は

- 代表的な（典型的には開発者がそのドメインの知識を用いて生成した少数の）入力に対する
- 実行時の検証

の事を指します。つまり開発者が「この入力に対してこの答えになってるなら多分上手く動いてるだろう」という大雑把な感覚をソースコードに落としたものです。これは限定的な入力しか検証していないので実装が正しいことを保証できない不完全な方法ですが、それでも多くの実装の間違いを低コストに検出することができ、そしてこれはソフトウェア開発において非常に有効に働くことが知られています。

| | 実装が正しい | 実装が間違っている |
| --- | --- | --- |
| テストが通る | 正しい | テストが足りない (この完全性はあきらめる) |
| テストが通らない | テストが間違っている (これはすぐに直す) | ここを低コストに検知できる事が重要 |

上で言うテスト以外にも実装が正しいかどうかを検証する様々な方法が存在します。

- コンパイル時の型検査も実装が正しいかの検査です。このように実際に実装を実行せずに検証を行うものを静的検査と呼び、テストのように実装を実行してみるものを動的検査と呼びます。
- [clippy](https://github.com/rust-lang/rust-clippy)のようなよくあるミスをソースコードから直接発見的に見つけるツール(Linterと呼ばれる)も静的検査の一つです。
- 数学の証明のように静的に任意の入力に対する正しさを検証するために、実装を数学的にモデル化して検証する方法は[形式手法](https://ja.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%89%8B%E6%B3%95)と呼ばれます。テストに比べると検証のためのコストが大きいので、特にバグがあると人が死ぬようなソフトウェアやOSや分散データベースのような非同期処理が多用されテストでは検証が不可能な場合に用いられます。
- 動的に任意の入力に対する正しさを検証するために入力をひたすら間違いを見つけるまで生成し続ける方法は[Fuzzing](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0)と呼ばれます。コンパイラのように複雑な入力を扱わなければならず人間がケースを列挙する方法では難しい場合に使われます。例えば [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz) を調べるといいでしょう。

# 静的な検証と実行時の検証

我々はどのような間違ったコードを書くのでしょうか？

静的に検証できる事と実行時に検証しないといけない事がある事を認識することが大事です。例えば

```rust
fn f(a: i32) {
    dbg!(a);
}
```

のような関数があるときに、 `f(1.0)` のように `f64` を渡すのは静的に検査できる事です。


# テストケースの自動生成と簡略化

ここではproptestによるテストケースの自動生成と簡略化について議論します。

https://github.com/proptest-rs/proptest
