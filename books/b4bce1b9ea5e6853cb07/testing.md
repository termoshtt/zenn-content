---
title: テストを書く
---

# なぜテストを書くのか？
テストは開発の効率を上げ、思いついた研究のアイディアを素早く検証することを補助してくれます。まずはモチベーションを理解するために次のようなストーリーを考えてみましょう。

数値計算で研究をしていると研究が進むたびに必要になった機能をどんどん実装し続けないといけません。ある機能を実装したらそれを使って実験をします。あなたは実験結果を可視化したところ上手くいっている図が得られて満足しこの機能（Aと呼びましょう）の開発は終わりました。
さて研究が進んで新しい機能Bが必要になりました。以前に実装した機能Aを少し変更すると機能Bの実装に使える事に気が付き、Aの実装を変更して機能Bを実装して実験し、結果を確認して新機能Bの実装は無事おわりました。
そして時は立ち機能Cを実装することになりました。やはりこれにも機能Aが、特に機能Bの時に使った部分とは別の部分が必要です。しかしこのコードは機能Bの時に変更されています。このコードは動くのでしょうか？機能Aを実装したのは随分と前です。試しに機能Aを使って機能Cを実装してみましたがどうも結果がおかしいです。結局あなたは機能Aの何が動いて何が動いていないのかを調べるため、ソースコードを読み始めることしました。しかしボスはなんで機能Cの実装は終わらないんだと怒り始めました...

このように次から次へと新しい開発項目が増えていってそれらを既存の機能を動くように保ちながら実装していくというのはソフトウェア開発において重要な課題であり、ソフトウェア開発がビジネスのコアとなっていくにしたがってその重要性は増していき様々な工夫が行われました。例えば次の資料によくまとまっています：

https://speakerdeck.com/twada/strategy-and-tactics-of-building-automated-testing-culture-into-organization-2020-autumn-edition?slide=10

その中で発達した技術の一つが自動テストです。自動テストの目的はどの機能が正しく動いているのかどうかを観測できるようにする事です。この本の初めに書いたようにこの本の目的の一つは一般的なソフトウェア開発において成功した技法を数値計算でも応用することです。

上の例で言えば機能Aにテストが整備されていたとすると、機能Cを実装するときはそのテストを実行するだけで機能Aが正しく動いているかどうかを確認できます。機能Bを実装するために機能Aの実装に手を入れたときも、そのテストを実行すれば機能Aの何がそのまま動いて何が動かなくなったのかが分かるので、必要以上に既存の機能を壊すことなく開発を行うことが出来るようになります。

あなたが今まで書いたコード群が何が動いて何が動かないのか不明で逐一確認しないといけない負債の山になるのか、それともどの機能がちゃんと動いているのかが一目でわかり他の機能を実装するために使える資産となるのか、その境目となるがテストです。

# テストの役割と限界、他の方法

テストの役割はコードが正しく動いている事を検証することです。特にプログラミングの文脈において「テスト」という単語は

- 代表的な（典型的には開発者がそのドメインの知識を用いて生成した少数の）入力に対する
- 実行時の検証

の事を指します。つまり開発者が「この入力に対してこの答えになってるなら多分上手く動いてるだろう」という大雑把な感覚をソースコードに落としたものです。これは限定的な入力しか検証していないので実装が正しいことを保証できない不完全な方法ですが、それでも多くの実装の間違いを低コストに検出することができ、そしてこれはソフトウェア開発において非常に有効に働くことが知られています。

| | 実装が正しい | 実装が間違っている |
| --- | --- | --- |
| テストが通る | 正しい | テストが足りない (この完全性はあきらめる) |
| テストが通らない | テストが間違っている (これはすぐに直す) | ここを低コストに検知できる事が重要 |

上で言うテスト以外にも実装が正しいかどうかを検証する様々な方法が存在します。

- コンパイル時の型検査も実装が正しいかの検査です。このように実際に実装を実行せずに検証を行うものを静的検査と呼び、テストのように実装を実行してみるものを動的検査と呼びます。
- [clippy](https://github.com/rust-lang/rust-clippy)のようなよくあるミスをソースコードから直接発見的に見つけるツール(Linterと呼ばれる)も静的検査の一つです。
- 数学の証明のように静的に任意の入力に対する正しさを検証するために、実装を数学的にモデル化して検証する方法は[形式手法](https://ja.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E6%89%8B%E6%B3%95)と呼ばれます。テストに比べると検証のためのコストが大きいので、特にバグがあると人が死ぬようなソフトウェアやOSや分散データベースのような非同期処理が多用されテストでは検証が不可能な場合に用いられます。
- 動的に任意の入力に対する正しさを検証するために入力をひたすら間違いを見つけるまで生成し続ける方法は[Fuzzing](https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%B8%E3%83%B3%E3%82%B0)と呼ばれます。コンパイラのように複雑な入力を扱わなければならず人間がケースを列挙する方法では難しい場合に使われます。例えば [cargo-fuzz](https://github.com/rust-fuzz/cargo-fuzz) を調べるといいでしょう。

このような多数の検証方法の中で、テストの特徴は次の２点です：

- 低コスト、つまり追加が簡単で高速に実行できること
- 開発者の実装対象に関する知識によって多くの間違いを検知できること

逆にこの範囲を逸脱すると途端にテストは役立たずになります。例えばテストで実装の正しさを保証しようとするのは誤りです。全てのコードがテストされていることを目指してはいけません。テストはあくまで少数のケースに対する実行で多くの間違いを検出するためのもので、どのようなケースを考えれば多くの間違いを検出できるのかは開発者の実装対象に対する知識に依存します。

逆に言えばテストを書くこと自体が開発者の知識を共有する手段としても機能します。例えば最も代表的な数値線形代数ライブラリである [LAPACKのテストスイート](https://www.netlib.org/lapack/lawnspdf/lawn09.pdf) には線型方程式や固有値・特異値の計算において問題となりやすい行列という極めて高度な知識が詰まっています。このようにテストを書く際には正常系を書く時よりもより高度な理論的な知識が必要になることが多く、これも数値計算に携わる科学者にとって重要な仕事となります。

# テストの書き方
さて座学が長くなりましたが、Rustのコードを書いていきましょう。Rustにおけるテストの書き方自体は公式ドキュメントが詳しいのでそちらを参照してください。

https://doc.rust-jp.rs/book-ja/ch11-00-testing.html

大雑把にまとめると

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[test]
fn test_name() {
    assert_eq!(add(1, 1), 2);
}
```

のように `#[test]` 属性をつけた関数をcrateのどこか、例えば `lib.rs` や `main.rs` に書くことでテストを書くことができます。これは普通の関数に属性が付いているだけなので普通の関数のように動き、通常のモジュール内の参照ルールに従ってモジュール中の関数や構造体を使う事が出来ます。テストは `cargo test` で実行できます。

しかしこのままだとこのcrateをリリースしたときにこの関数もそのままリリースされてしまって、それはコンパイル時間が増えたりしたりして不都合があるので、条件付きコンパイルの機能を使ってテストの時だけビルドされるようにするのが一般的です。

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]  // これは `mod` 句に対する属性なので `cargo test` の時だけ `mod test { ... }` の部分が存在することになる
mod test {
    use super::add;  // 一つ上の名前空間は `super` で参照できる

    #[test]
    fn test_name() {
        assert_eq!(add(1, 1), 2);
    }
}
```

またテストの時だけ使う外部crateを指定することもできて、例えばスナップショットテスト用crate [insta](https://docs.rs/insta/latest/insta/) を使いたい場合は次のように `Cargo.toml` に書きます：

```toml: Cargo.toml
[dev-dependencies]
insta = "1.36.1"
```

## 異常系のテスト

実行が失敗するケースをテストとして書くこともできます。

```rust
fn div(a: f32, b: f32) -> f32 {
    assert!(b != 0.0);
    a / b
}

#[should_panic]
#[test]
fn zero_div() {
    div(1.0, 0.0);  // assertion failed!
}
```

プログラムが不正な入力をもらったケースは正常な入力をもらったケースに対して異常系と呼ばれますが、開発者は通常正常系で上手く動いたらそれで満足して、自分が書いた不正な入力を処理するコードの事を忘れてしまいがちです。すると後で「このケースはエラーになるからエラーになってないなら正しいはず」と思ってコードを書いた結果、バグが残っていて不正な入力に対してエラーになってないので、それを使ったコードの結果も間違っているという事が良く起きます。異常系の処理を書いたらそれを再現するテストを書く習慣を付けましょう。

# 何をテストするか？

上で見たようにテストというのは次のステップからなります：

1. 必要なデータや状態を用意する
2. そのデータや状態を使って実装を実行する
3. その実装の結果を検証する

実装はテストと関係なくあるはずなので問題は次の二つです。

- どのデータや状態を使ってテストを行うか
- その結果をどう検証するか

例えばあなたが書いたコードが計算結果としてベクトルや行列を出力する場合、その結果を正しく比較するにはそのデータが何を近似的に表現しているのかに本質的に依存します。
例えばベクトルが本来はある１次元領域 $\Omega$ 上の $L^\infty (\Omega)$ の関数 $f: \Omega \to \mathbb{R}$ の離散化であるなら、そのベクトルの要素同士の差が小さいかどうか (つまり$L^\infty$-ノルムで十分近いか) を検証することが適切となり、 $L^2(\Omega)$ の関数の離散化であるなら2乗誤差が小さいかどうかを検証することが適切です。

また相対誤差で比較するべきなのか絶対誤差で比較するべきなのかも重要です。典型的には答えが$0$になるときは絶対誤差で評価し、それ以外の場合は相対誤差で評価するのが適切となる場合が多いですが、これは問題に依存するので都度考えてください。

例えばフーリエ変換をする際、不連続点があるとその近傍で級数の収束が遅くなります：

https://ja.wikipedia.org/wiki/%E3%82%AE%E3%83%96%E3%82%BA%E7%8F%BE%E8%B1%A1

開発しているシステムの要件によってこのような不連続点をもつ関数に対してどのような振る舞いをするのかを検証する必要がある場合と無い場合があるでしょうが、知識がないとそもそもこのケースを検証しようとはなりません。このような計算しようとしている元々のシステムには存在せず、数値計算を行って初めて現れるような問題というのは意外とたくさんあります。私も流体系のシミュレーションコードを書き始めてから関数解析を一から勉強しなおしました。

このような「上手くいかない入力」は残念ながらソフトウェアのエンドユーザーが運用でカバーしているケースが多く、しかしそれでは「何が動いて何が動かないか実験してみないと分からない」システムに逆戻りです。これを回避するために開発者はその実装がどのような入力に対して正しく動くかを考え、動かないケースに対しては失敗するということを明示的に示すことが重要です。

# テスト技法

## 乱数列の再現
TBW

## テストケースの自動生成と簡略化 (Property-based testing)

ここではproptestによるテストケースの自動生成と簡略化について議論します。

https://github.com/proptest-rs/proptest

TBW

## スナップショットテスト

https://insta.rs/

TBW

## 可視化を必要とするテスト
TBW

## テストではなく型で検証するべきケース
TBW

