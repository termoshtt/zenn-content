---
title: "より強いテスト入力生成のためのConcolic実行"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "PBT", "fuzzing"]
published: false
---

最近Property-Based Testing (PBT) が普及しており、私も業務で [proptest] を使っています。PBTの利点は広く解説されているので割愛しますが、個人的には次の問題があると感じています。

- Propertyを考えれるケースが限られる
- テストケースの生成能力が低い

特に私が主に扱うソフトウェアである数値計算ライブラリにおいては、前者は数学的なドメイン知識からある程度は補助できるものの、後者が大きな問題となっています。
今回は後者に関して、Concolic Execution (Concrete + Symbolic Execution) という技術を紹介したいと思います。最初に断っておきますが、これはすぐにPBTに組み込めるような方法ではないので、この記事は調査・実験の記録だと思ってください。

[proptest]: https://github.com/proptest-rs/proptest

# 充足問題としてのPBT

PBTについて簡単に説明していきましょう。PBTというのは大雑把にいうと、あるデータ `x: A` が何かしらの前提条件を満たすときに、ある性質が成り立つことを検証するテスト手法です。例えば

- 整数 `x: i64` が前提条件 `0 <= x < 100` を満たすとき、性質 `x * 2 < 200` が成り立つ

のような形をしており、これを [proptest] で書くと次のようになります。

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn x_times_two_is_less_than_200(x in 0i64..100) {
        prop_assert!(x * 2 < 200);
    }
}
```

PBTフレームワークはこのようにユーザーが記述した前提条件と性質に対してそれに違反するテストケースを生成し、可能であればより単純な違反ケースを探索してくれます。

ではどうやって違反ケースを生成するのでしょうか？

最も基本的な戦略はランダムにデータを生成し、前提条件を満たさなければ捨てて、満たしていた場合は性質を検証するというものです。PBTは前提条件の元で性質が成り立つことを証明する手法ではなくて、性質が成り立たない反例を見つけるヒューリスティクスです。ランダムに生成すると言っても、上の例で言えば任意の整数を生成してから `0 <= x < 100` を満たすまで繰り返すのは採択率が低すぎて非効率であり、`[0, 100)` の一様乱数を生成するような工夫がされています。PBTフレームワークではこのような前提条件を満たすデータを生成する方法を多数サポートしています。

この戦略の明らかな問題点は生成能力が低いことです。

- 前提条件が複雑になると生成するのが困難であるためRejection Samplingに頼らざるを得ないが、当然これは採択率が低く非効率
  - ドメイン知識によって特定の性質を満たすデータを効率よく生成するジェネレータを設計できるケースは多くあるため、PBTを使うというのはこの実装を詰めるというのが主な作業になることが多い
- 検証する性質をブラックボックスとして扱うので、性質のことを知っていれば容易に発見できる反例を自動的に検知できない
  - やはりドメイン知識をもとに性質が破れやすいケースをジェネレータにハードコードすることになる

結果として「成り立つべき性質を記述したら自動的に失敗するケースを見つけてくれる」というPBTの理想からは遠く、ドメイン知識をもとに失敗ケースを効率よく生成するジェネレータをプログラマが頑張って書くという形になりがちです。

# 条件分岐のフィードバック: Coverage-Guided Fuzzing

さてPBTでは性質をブラックボックスとして扱うため、性質のことを知っていれば容易に発見できる反例を自動的に検知できないという問題がありました。例えば次の性質を考えましょう

```rust
fn is_special_integer(x: i64) -> bool {
    if x == 114514 {
        return true;
    } else {
        return false;
    }
}
```

PBTで `is_special_integer(x) == false` という性質を検証したいとします。この性質を破る反例を見つけるには `x == 114514` を満たす `x` を生成する必要があります。しかしPBTは性質をブラックボックスとして扱うため、 `is_special_integer` の中身を知らないので `114514` という数値は知り得ません。ランダムに整数を生成している限り `114514` が生成される確率は非常に低く、現実的な時間内に反例を見つけることは困難です。これは浮動小数点数に対してはさらに深刻になります。検証するべき性質を完全にブラックボックスにしてしまうと反例の生成能力が著しく低下してしまうのです。

これに対してCoverage-Guided Fuzzing (CGF) という技術があります。これは性質の中の条件分岐を実行時にトレースすることで、性質をホワイトボックスとは行かないまでもグレーボックス的に扱う手法です。実行時にトレースを取得する方法はいくつかあり、大きく分けてコンパイル時にインストルメントを挿入する方法と、動的にバイナリを解析してトレースを取得する方法があります。Rustでは [cargo-fuzz] がLLVMのインストルメントを利用したCGFを提供しています。

[cargo-fuzz]: https://github.com/rust-fuzz/cargo-fuzz

例えば `x = 0` で `is_special_integer` を実行したとします。このとき最初の命令で `x == 114514` という比較を `x=0` で行なって一致しなかったというトレースが得られます。CGFはこのトレースを解析し、 `x == 114514` をサンプルとして記録し、記録されたサンプルから変異を加えた新しい入力を生成し、先ほど通ったトレースとは異なるトレースを通ることを目指します。こうしてCGFは性質の中の条件分岐を網羅的に探索し、より多くの反例を効率的に探査することができます。


# Symbolic Execution

CGFは導入が比較的容易で反例生成能力が向上する方法で、特に単純な一致による分岐に対しては有効です。しかし例えば `f(x) == 1` のように変数を変換してから比較するケースではどうなるでしょうか？これは方程式 $f(x) = 1$ を解く必要がありますが、例えば $f$ として暗号学的ハッシュ関数を適用していたら上手くいかないのは明らかでしょう。ではもっと単純な変換、例えばアフィン変換 $f(x) = 2x + 3$ なら？多項式 $f(x) = x^3 - x + 7$ なら？これなら出来そうですがそのために解決するべき問題が二つあって

- 方程式を解くソルバーが必要
- 方程式自体をプログラムから抽出する必要

これらを解決するのが Symbolic Execution です。具体的な問題を考えながら説明していきましょう:

```rust
fn is_adequate_integer(x: i64) -> bool {
    let y = 2 * x + 3;
    let z = y * y - y - 7;
    z >= 1
}
```

この性質に違反する（ `is_adequate_integer(x) == false` を満たす）整数 `x` を見つけたいとします。我々はコードを見ることで、これは次の連立方程式を $x$ について解くことと同値であることがわかります。

$$
\begin{cases}
y = 2x + 3 \\\\
z = y^2 - y - 7 \\\\
z < 1
\end{cases}
$$

これをプログラムから自動的に抽出する方法を考えましょう。プログラムを解析する基本的な方法は実行しながらトレースを取ることですが、今回は通常の意味論と少し違います。通常はある決まった `x` の値が呼び出し元から与えられて、それに対して `y = 2 * x + 3` と `z = y * y - y - 7` を計算して、最後に `z >= 1` を評価します。しかし今考えるべきは具体的な値が与えら得ていないシンボルの `x` です。これは通常のRustの変数とは意味合いが異なる、反例生成のために解くべき方程式の変数としての `x` なのでシンボルと呼称します。これは次のような意味論を与えることになります。

```rust
fn is_adequate_integer(x: i64) -> bool {  // x をシンボルとして追加
    let y = 2 * x + 3;     // y をシンボルとして追加, y = 2x + 3 という式を記録
    let z = y * y - y - 7; // z をシンボルとして追加, z = y^2 - y - 7 という式を記録
    z >= 1                 // 今 is_adequate_integer(x) == false を満たす x を見つけたいので、 !(z >= 1) という条件を記録
}
```

この意味論に基づいたインタプリタを初期化し、性質を表すコードを上から順番に *実行* すれば、今欲しかった方程式を得ることができるという仕組みです。

このようにしてプログラムを方程式に変換すれば、あとはこの方程式を適切なソルバーに渡して解きます。ソルバーが解を返してくれば性質を破る反例になり、ソルバーが解なしを証明すれば性質が成り立つことが証明できます。このような体系をSymbolic Executionと呼びます。

Symbolic Executionの代表的なプロジェクトとして [KLEE](https://klee-se.org/) があります、これはLLVM IRに対するインタプリタとして動作し、C言語のプログラムに対してSymbolic Executionを提供するプロジェクトで、[実際に多くのバグを発見するなど成功を収めています](https://llvm.org/pubs/2008-12-OSDI-KLEE.pdf)。

# Concolic Execution

Symbolic Executionは強力ですが実用しようとするといくつか難しい問題があります。
