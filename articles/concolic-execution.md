---
title: "より強いテスト入力生成のためのConcolic実行"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "PBT", "fuzzing"]
published: false
---

最近Property-Based Testing (PBT) が普及しており、私も業務で [proptest] を使っています。PBTの利点は広く解説されているので割愛しますが、個人的には次の問題があると感じています。

- Propertyを考えれるケースが限られる
- テストケースの生成能力が低い

今回は後者に関して、Concolic Execution (Concrete + Symbolic Execution) という技術を紹介したいと思います。最初に断っておきますが、これはすぐにPBTに組み込めるような方法ではないです。なお基本的にRustの用語で説明します。

[proptest]: https://github.com/proptest-rs/proptest

:::message
以下の内容は私が理解した内容を書いていますが、用語は完全にAIに頼っており正確でない可能性があります。もし誤りを見つけたら教えてください。
:::

# 充足問題としてのPBT

PBTについて簡単に説明していきましょう。PBTというのは大雑把にいうと、あるデータ `x: A` が何かしらの前提条件を満たすときに、ある性質が成り立つことを検証するテスト手法です。例えば

- 整数 `x: i64` が前提条件 `0 <= x < 100` を満たすとき、性質 `x * 2 < 200` が成り立つ

のような形をしており、これを [proptest] で書くと次のようになります。

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn x_times_two_is_less_than_200(x in 0i64..100) {
        prop_assert!(x * 2 < 200);
    }
}
```

PBTフレームワークはこのようにユーザーが記述した前提条件と性質に対してそれに違反するテストケースを生成し、可能であればより単純な違反ケースを探索してくれます。

ではどうやって違反ケースを生成するのでしょうか？

最も基本的な戦略はランダムにデータを生成し、前提条件を満たさなければ捨てて、満たしていた場合は性質を検証するというものです。PBTは前提条件の元で性質が成り立つことを証明する手法ではなくて、性質が成り立たない反例を見つけるヒューリスティクスです。ランダムに生成すると言っても、上の例で言えば任意の整数を生成してから `0 <= x < 100` を満たすまで繰り返すのは採択率が低すぎて非効率であり、`[0, 100)` の一様乱数を生成するような工夫がされています。PBTフレームワークではこのような前提条件を満たすデータを生成する方法を多数サポートしています。

この戦略の明らかな問題点は生成能力が低いことです。

- 前提条件が複雑になると生成するのが困難であるためRejection Samplingに頼らざるを得ないが、当然これは採択率が低く非効率
  - ドメイン知識によって特定の性質を満たすデータを効率よく生成するジェネレータを設計できるケースは多くあるため、PBTを使うというのはこの実装を詰めるというのが主な作業になることが多い
- 検証する性質をブラックボックスとして扱うので、性質のことを知っていれば容易に発見できる反例を自動的に検知できない
  - やはりドメイン知識をもとに性質が破れやすいケースをジェネレータにハードコードすることになる

結果として「成り立つべき性質を記述したら自動的に失敗するケースを見つけてくれる」というPBTの理想からは遠く、ドメイン知識をもとに失敗ケースを効率よく生成するジェネレータをプログラマが頑張って書くという形になりがちです。

# 条件分岐のフィードバック: Coverage-Guided Fuzzing

さてPBTでは性質をブラックボックスとして扱うため、性質のことを知っていれば容易に発見できる反例を自動的に検知できないという問題がありました。例えば次の性質を考えましょう

```rust
fn is_special_integer(x: i64) -> bool {
    if x == 114514 {
        return true;
    } else {
        return false;
    }
}
```

PBTで `is_special_integer(x) == false` という性質を検証したいとします。この性質を破る反例を見つけるには `x == 114514` を満たす `x` を生成する必要があります。しかしPBTは性質をブラックボックスとして扱うため、 `is_special_integer` の中身を知らない限りこの条件分岐に到達することはできません。ランダムに整数を生成している限り `114514` が生成される確率は非常に低く、現実的な時間内に反例を見つけることは困難です。これは浮動小数点数に対してはさらに深刻になります。

これに対してCoverage-Guided Fuzzing (CGF) という技術があります。これは性質の中の条件分岐を実行時にトレースすることで、性質をホワイトボックスとは行かないまでもグレーボックス的に扱う手法です。実行時にトレースを取得する方法はいくつかあり、大きく分けてコンパイル時にインストルメントを挿入する方法と、動的にバイナリを解析してトレースを取得する方法があります。Rustでは [cargo-fuzz] がLLVMのインストルメントを利用したCGFを提供しています。

[cargo-fuzz]: https://github.com/rust-fuzz/cargo-fuzz

例えば `x = 0` で `is_special_integer` を実行したとします。このとき最初の命令で `x == 114514` という比較を `x=0` で行なって一致しなかったというトレースが得られます。CGFはこのトレースを解析し、 `x` の値を `114514` に近づけるような変異を加えた新しい入力を生成し、先ほど通ったトレースとは異なるトレースを通ることを目指します。こうしてCGFは性質の中の条件分岐を網羅的に探索し、より多くの反例を効率的に探査することができます。

これは定数の比較に対しては有効ですが、例えば `x` に暗号学的ハッシュ関数を適用していてから比較していたら、これは上手くいかないのは明らかでしょう。ではもっと単純な変換、例えばアフィン変換 `2 * x + 4 == 114514` なら？多項式 `x^3 - x + 7 == 114514` なら？このような場合は上手くフィードバックすれば効率的に反例を見つけられるかもしれないですが、これには条件分岐の瞬間だけをトレースしては不十分で、条件分岐に使っている値がどのように計算されたかを追跡する必要があります。

# Symbolic Execution

条件分岐を網羅的に探索するには、条件分岐に使われている値がどのように計算されたかを追跡する必要があると述べました。これを実現する技術としてSymbolic Executionがあります。

```rust
fn is_special_integer(x: i64) -> bool {
    let y = 2 * x + 4;
    let z = y * y - y + 7;
    if z == 114514 {
        return true;
    } else {
        return false;
    }
}
```


