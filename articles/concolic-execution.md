---
title: "より強いテスト入力生成のためのConcolic実行"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "PBT", "fuzzing"]
published: false
---

最近Property-Based Testing (PBT) が普及しており、私も業務で [proptest] を使っています。PBTの利点は広く解説されているので割愛しますが、個人的には次の問題があると感じています。

- Propertyを考えれるケースが限られる
- テストケースの生成能力が低い

特に私が主に扱うソフトウェアである数値計算ライブラリにおいては、前者は数学的なドメイン知識からある程度は補助できるものの、後者が大きな問題となっています。
今回は後者に関して、Concolic Execution (Concrete + Symbolic Execution) という技術を紹介したいと思います。最初に断っておきますが、これはすぐにPBTに組み込めるような方法ではないので、この記事は調査・実験の記録だと思ってください。

[proptest]: https://github.com/proptest-rs/proptest

# 充足問題としてのPBT

PBTについて簡単に説明していきましょう。PBTというのは大雑把にいうと、あるデータ `x: A` が何かしらの前提条件を満たすときに、ある性質が成り立つことを検証するテスト手法です。例えば

- 整数 `x: i64` が前提条件 `0 <= x < 100` を満たすとき、性質 `x * 2 < 200` が成り立つ

のような形をしており、これを [proptest] で書くと次のようになります。

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn x_times_two_is_less_than_200(x in 0i64..100) {
        prop_assert!(x * 2 < 200);
    }
}
```

PBTフレームワークはこのようにユーザーが記述した前提条件と性質に対してそれに違反するテストケースを生成し、可能であればより単純な違反ケースを探索してくれます。

ではどうやって違反ケースを生成するのでしょうか？

最も基本的な戦略はランダムにデータを生成し、前提条件を満たさなければ捨てて、満たしていた場合は性質を検証するというものです。PBTは前提条件の元で性質が成り立つことを証明する手法ではなくて、性質が成り立たない反例を見つけるヒューリスティクスです。ランダムに生成すると言っても、上の例で言えば任意の整数を生成してから `0 <= x < 100` を満たすまで繰り返すのは採択率が低すぎて非効率であり、`[0, 100)` の一様乱数を生成するような工夫がされています。PBTフレームワークではこのような前提条件を満たすデータを生成する方法を多数サポートしています。

この戦略の明らかな問題点は生成能力が低いことです。

- 前提条件が複雑になると生成するのが困難であるためRejection Samplingに頼らざるを得ないが、当然これは採択率が低く非効率
  - ドメイン知識によって特定の性質を満たすデータを効率よく生成するジェネレータを設計できるケースは多くあるため、PBTを使うというのはこの実装を詰めるというのが主な作業になることが多い
- 検証する性質をブラックボックスとして扱うので、性質のことを知っていれば容易に発見できる反例を自動的に検知できない
  - やはりドメイン知識をもとに性質が破れやすいケースをジェネレータにハードコードすることになる

結果として「成り立つべき性質を記述したら自動的に失敗するケースを見つけてくれる」というPBTの理想からは遠く、ドメイン知識をもとに失敗ケースを効率よく生成するジェネレータをプログラマが頑張って書くという形になりがちです。

# 条件分岐のフィードバック: Coverage-Guided Fuzzing

さてPBTでは性質をブラックボックスとして扱うため、性質のことを知っていれば容易に発見できる反例を自動的に検知できないという問題がありました。例えば次の性質を考えましょう

```rust
fn is_special_integer(x: i64) -> bool {
    if x == 114514 {
        return true;
    } else {
        return false;
    }
}
```

PBTで `is_special_integer(x) == false` という性質を検証したいとします。この性質を破る反例を見つけるには `x == 114514` を満たす `x` を生成する必要があります。しかしPBTは性質をブラックボックスとして扱うため、 `is_special_integer` の中身を知らないので `114514` という数値は知り得ません。ランダムに整数を生成している限り `114514` が生成される確率は非常に低く、現実的な時間内に反例を見つけることは困難です。これは浮動小数点数に対してはさらに深刻になります。検証するべき性質を完全にブラックボックスにしてしまうと反例の生成能力が著しく低下してしまうのです。

これに対してCoverage-Guided Fuzzing (CGF) という技術があります。これは性質の中の条件分岐を実行時にトレースすることで、性質をホワイトボックスとは行かないまでもグレーボックス的に扱う手法です。実行時にトレースを取得する方法はいくつかあり、大きく分けてコンパイル時にインストルメントを挿入する方法と、動的にバイナリを解析してトレースを取得する方法があります。Rustでは [cargo-fuzz] がLLVMのインストルメントを利用したCGFを提供しています。

[cargo-fuzz]: https://github.com/rust-fuzz/cargo-fuzz

例えば `x = 0` で `is_special_integer` を実行したとします。このとき最初の命令で `x == 114514` という比較を `x=0` で行なって一致しなかったというトレースが得られます。CGFはこのトレースを解析し、 `x == 114514` をサンプルとして記録し、記録されたサンプルから変異を加えた新しい入力を生成し、先ほど通ったトレースとは異なるトレースを通ることを目指します。こうしてCGFは性質の中の条件分岐を網羅的に探索し、より多くの反例を効率的に探査することができます。


# Symbolic Execution

CGFは導入が比較的容易で反例生成能力が向上する方法で、特に単純な一致による分岐に対しては有効です。しかし例えば `f(x) == 1` のように変数を変換してから比較するケースではどうなるでしょうか？これは方程式 $f(x) = 1$ を解く必要がありますが、例えば $f$ として暗号学的ハッシュ関数を適用していたら上手くいかないのは明らかでしょう。ではもっと単純な変換、例えばアフィン変換 $f(x) = 2x + 3$ なら？多項式 $f(x) = x^3 - x + 7$ なら？これなら出来そうですがそのために解決するべき問題が二つあって

- 方程式を解くソルバーが必要
- 方程式自体をプログラムから抽出する必要

これらを解決するのが Symbolic Execution です。具体的な問題を考えながら説明していきましょう:

```rust
fn is_adequate_integer(x: i64) -> bool {
    let y = 2 * x + 3;
    let z = y * y - y - 7;
    z >= 1
}
```

この性質に違反する（ `is_adequate_integer(x) == false` を満たす）整数 `x` を見つけたいとします。我々はコードを見ることで、これは次の連立方程式を $x$ について解くことと同値であることがわかります。

$$
\begin{cases}
y = 2x + 3 \\\\
z = y^2 - y - 7 \\\\
z < 1
\end{cases}
$$

これをプログラムから自動的に抽出する方法を考えましょう。プログラムを解析する基本的な方法は実行しながらトレースを取ることですが、今回は通常の意味論と少し違います。通常はある決まった `x` の値が呼び出し元から与えられて、それに対して `y = 2 * x + 3` と `z = y * y - y - 7` を計算して、最後に `z >= 1` を評価します。しかし今考えるべきは具体的な値が与えら得ていないシンボルの `x` です。これは通常のRustの変数とは意味合いが異なる、反例生成のために解くべき方程式の変数としての `x` なのでシンボルと呼称します。これは次のような意味論を与えることになります。

```rust
fn is_adequate_integer(x: i64) -> bool {  // x をシンボルとして追加
    let y = 2 * x + 3;     // y をシンボルとして追加, y = 2x + 3 という式を記録
    let z = y * y - y - 7; // z をシンボルとして追加, z = y^2 - y - 7 という式を記録
    z >= 1                 // 今 is_adequate_integer(x) == false を満たす x を見つけたいので、 !(z >= 1) という条件を記録
}
```

この意味論に基づいたインタプリタを初期化し、性質を表すコードを上から順番に *実行* すれば、今欲しかった方程式を得ることができるという仕組みです。

このようにしてプログラムを方程式に変換すれば、あとはこの方程式を適切なソルバーに渡して解きます。ソルバーが解を返してくれば性質を破る反例になり、ソルバーが解なしを証明すれば性質が成り立つことが証明できます。このような体系をSymbolic Executionと呼びます。

Symbolic Executionの代表的なプロジェクトとして [KLEE](https://klee-se.org/) があります、これはLLVM IRに対するインタプリタとして動作し、C言語のプログラムに対してSymbolic Executionを提供するプロジェクトで、[実際に多くのバグを発見するなど成功を収めています](https://llvm.org/pubs/2008-12-OSDI-KLEE.pdf)。

# Concolic Execution

Symbolic Executionは強力ですが実用しようとするといくつか難しい問題があります

- 具体的な値を伴わない、異なる意味論で実行するので元の挙動を完全に再現できない
  - 単純な整数や文字列の処理程度なら実現可能だが、例えばシンボルに対して正規表現によるマッチくらいでも専用のモデル化が必要になる。さらにファイルシステムやネットワークなどの外部環境とのインタラクションを伴うコードにシンボルが入るとモデル化が非常に困難になる
- ループを含むコードを扱うのが難しい
  - 例えば `while x > 0 { x -= 1; }` のようなコードがあったとき、 `x` がシンボルであればこのループは無限に展開されることになる。これを解決するためには、ループの展開を制限するか、ループの挙動をモデル化する必要がある
- モデル化できたとして、ソルバーが解けるとは限らない

そこでSymbolicな変数の追跡を行いながら具体的な値を使って実行するConcolic (=Concrete + Symbolic) Executionという手法があります。具体的な値を使って実行するので元の挙動を再現できるし、同時にシンボルの追跡も行うのでCGFに比べて非常に多くの情報を得ることができます。

Symbolic Executionでは条件分岐があった時、その両方のパスを解析して完全な論理式に変換していました。

```rust
fn is_adequate_integer2(x: i64) -> bool {  // x をシンボルとして追加
    let y = 2 * x + 3;     // y をシンボルとして追加, y = 2x + 3 という式を記録
    let z = y * y - y - 7; // z をシンボルとして追加, z = y^2 - y - 7 という式を記録
    if z >= 1 {            // z はシンボルなので両方のパスを記録する必要がある
        z * z <= 10        // z >= 1 and z * z <= 10 という式を記録
    } else {
        z * z >= 10        // z < 1 and z * z >= 10 という式を記録
    }  // if式全体で (z >= 1 and z * z <= 10) or (z < 1 and z * z >= 10) という式を記録
}
```

このようにして得られた論理式をSMTソルバーに渡して解くことで、性質を破る反例を見つけることを目的としていました。これは全部のパスを適切にモデル化出来ているならば意味がある方法ですが、上述したように全体のモデル化は難しく、具体的に通っていないパスはモデル化が不十分なので、全部のパスに対する充足問題を解いてもあまり意味がないことになります。

そこでConcolic Executionではいきなり反例を探しにいくのではなくて、今通ったパスとは違うパスを通る入力を生成するという方針を取ります。CGFではランダム生成によって別のパスに行く入力を探していましたが、Concolic実行では異なるパスを発見するためにSymbolicに抽出した条件式とSMTソルバーを使います。Concolic Executionでは条件分岐があった時、実際の値に基づいて片方のパスだけをモデル化します

```rust
fn is_adequate_integer2(x: i64) -> bool {  // x をシンボルとして追加, 例えば x = 0 で開始
    let y = 2 * x + 3;     // y をシンボルとして追加, y = 2x + 3 という式を記録, y = 2*0 + 3 = 3 という具体的な値も記録
    let z = y * y - y - 7; // z をシンボルとして追加, z = y^2 - y - 7 という式を記録, z = 3^2 - 3 - 7 = -1 という具体的な値も記録
    if z >= 1 {            // z >= 1 の条件を記録し、z = -1 なので false のパスに行くことも記録
        z * z <= 10        // ここは通らない
    } else {
        z * z >= 10        // z = -1 なので z * z >= 10 は false であることを記録
    } // 結局 z >= 1 を false で、 z * z >= 10 を false で通ったというパスが記録される
}
```

コメントにあるように `x = 0` で開始すると `y = 2x + 3 (= 3)` かつ `z = y^2 - y -7 (= -1)` で  `z >= 1` を false で通り、 `z * z >= 10` を false で通ったという結果が得られます。パスの探索戦略として色々ありますが、例えば深さ優先で探索するんだと次は `z >= 1`　が false かつ `z * z >= 10` が true になるような入力を探します。

このようにConcolic ExecutionはSymbolic ExecutionとCGFのいいとこ取りをしたような手法で、CGFよりも強力な反例生成能力を持ちつつ、Symbolic Executionのような完全なモデル化を必要としないので実用的な方法になっています。

# 実装してみた

https://github.com/termoshtt/concolic-pbt

実用的なプロジェクトは大変そうなので、学習用にまず簡単な例として、整数の加法と変数および条件分岐だけからなるごくごく簡単な言語を定義します。

```text
expr       := if_expr | arith_expr
if_expr    := "if" bool_expr "then" expr "else" expr
arith_expr := term (('+' | '-') term)*
term       := number | var | '(' expr ')'

bool_expr  := "true" | "false" | expr cmp_op expr
cmp_op     := "<=" | ">=" | "=="

var        := [a-z][a-z0-9_]*
number     := '-'? [0-9]+
```

例えば `if x <= 10 then x + 1 else 0` のような式をこの言語で表現できます。これを `x = 5` で評価すると `x <= 10` は true　なので `x + 1 = 6` になります。

```rust
let expr = parse_expr("if x <= 10 then x + 1 else 0").unwrap();

let mut state = ConcolicState::new(HashMap::from([("x".to_string(), 5)])); // x = 5 で開始
insta::assert_snapshot!(state.eval(&expr), @"6"); // 評価結果は 6
insta::assert_snapshot!(state, @r#"
Env: x = 5
Constraints:
    x [=5] <= 10 : true
"#);  // 評価の過程で x <= 10 を true で通ったことが記録される
```

パスの探索は次のように行います

```rust
// Property: (if x <= 5 then (if x >= 10 then 0 else 1) else 1) >= 1
// The path (x <= 5, true) -> (x >= 10, true) is unreachable (x <= 5 and x >= 10 is contradictory)
let property = parse_bool_expr("(if x <= 5 then (if x >= 10 then 0 else 1) else 1) >= 1").unwrap();

// ソルバーを用意します（現在ソルバーは簡易的なReject Samplingですが、将来的にはZ3などのSMTソルバーを使う予定です）
let rng = rand::rngs::StdRng::seed_from_u64(42);
let solver = Solver::new(rng, 100);

// 深さ優先でパスを探索します
let mut explorer = Explorer::new(solver, 100);
let initial_env = HashMap::from([("x".to_string(), 3)]); // x = 3 から探索スタート
let result = explorer.find_counterexample(&property, initial_env);

// 今回は成立する性質を検査しているので、反例が見つからなかった
assert_eq!(result, ExploreResult::Verified);
// 通ったパスを内部で記録しています。
insta::assert_snapshot!(explorer, @r#"
Reached:
    Path: TFT
    Env: x = 3
    Path: FT
    Env: x = 149

Unreached:
    Path: TFF
    Path: TT
    Path: FF
"#);
```

1. 探索は `x = 3` で開始すると、これは `x <= 5` を true で通り、 `x >= 10` を false で通り、最後に `1 >= 1` なので true で `TFT` というパスを通ります。
2. 深さ優先探索なのでまず最後の条件を反転した `TFF` を探しますが、最後の `1 >= 1` を false では通れないのでこれは unreachable になります。
3. 次に二つ目を反転した `TT`、つまり `x <= 5` かつ `x >= 10` が true になるような入力を探します。しかしこれは数学的に矛盾しているのでこれも unreachable になります。ここで最初の二つの条件だけをみている（`TTT` などを探しに行っていない）ことに注意してください。 `TT` のブランチはまだ具体的に通ってないので、どういう条件分岐があるのか調べていません。
4. 次に最初の条件 `x <= 5` を false で通る `F` を探します。ソルバーはここで `x = 149` という入力を見つけました。これで評価すると次は `if x <= 5 then ... else 1 = 1` なので `1 >= 1` を true で通る `FT` というパスを通ります。`F` を探しに来て `FT` を通ったことに注意してください。
5. 最後に `FT` の最後の条件を反転した `FF` を探しますが、これも `1 >= 1` を false で通ることはできないので unreachable になります。これで全部のパスを探索したので終了します。

随分と限定的ですが、与えられたASTに対してシンボリックに条件式を抽出し、それを元にソルバーで探索するというConcolic Executionの基本的な流れを実装できたと思います。
